{"version":3,"file":"component.min.js","sources":["../src/Component.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nfunction isUndefined(value: any): boolean {\n    return typeof value === \"undefined\";\n}\n\ninterface DefaultProps<T> {\n  eventType: string;\n  stop: () => void;\n  currentTarget: T;\n}\n\ntype EventNoParamKey<T extends EventMap, K extends EventKey<T>> = T[K] extends NoArguments\n  ? K\n  : never;\ntype NotFunction = { [k: string]: unknown } & ({ bind?: never } | { call?: never });\ntype NoArguments = undefined | null | void | never;\ntype EventWithRestParam = ((evt: NotFunction, ...restParam: any[]) => any);\n\n/**\n * Types that can be used when attaching new event definition as generic on a class\n * @ko 클래스 타입 등록시 사용가능한 타입\n * @example\n * new SomeClass<{\n *   // Using it as object\n *   evt0: {\n *     param0: number;\n *     param1: string\n *   };\n *   // Using it as function with other arguments\n *   evt1: (arg0: {\n *     param0: number;\n *     param1: string\n *   }, arg1: string, arg2: boolean) => boolean;\n * }>\n */\ntype EventDefinition = NotFunction | NoArguments | EventWithRestParam;\n\ntype EventMap = Record<string, EventDefinition>;\ntype EventKey<T extends EventMap> = string & keyof T;\ntype EventHash<T extends EventMap, S> = Partial<{ [K in EventKey<T>]: EventCallback<T, K, S> }>;\n\ntype EventCallback<T extends EventMap, K extends EventKey<T>, S>\n  = T[K] extends NoArguments\n    ? (event: DefaultProps<S>) => any\n    : T[K] extends (evt: infer U, ...restParam: infer V) => any\n      ? (event: U & DefaultProps<S>, ...restParam: V) => any\n      : (event: T[K] & DefaultProps<S>) => any;\ntype FirstParam<T extends EventMap, K extends EventKey<T>>\n  = T[K] extends NoArguments\n    ? void\n    : T[K] extends (evt: infer U, ...restParam: any[]) => any\n      ? U\n      : T[K];\ntype RestParam<T extends EventMap, K extends EventKey<T>>\n  = T[K] extends (evt: NotFunction, ...restParam: infer U) => any\n    ? U\n    : void[]\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\nclass Component<T extends EventMap = EventMap> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @type {String}\n   * @example\n   * eg.Component.VERSION;  // ex) 2.0.0\n   * @memberof eg.Component\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n\n  /**\n   * @deprecated\n   */\n  public options: {[key: string]: any} = {};\n  private _eventHandler: {[keys: string]: EventCallback<T, EventKey<T>, Component<T>>[]};\n\n  /**\n   * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n   */\n  constructor() {\n    this._eventHandler = {};\n  }\n\n  /**\n   * Triggers a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {String} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n   * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">Ref</a> <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 'false'를 반환하고 이벤트 발생을 중단한다. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">참고</a></ko>\n   * @example\n   * class Some extends eg.Component {\n   *   some(){\n   *     if(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n   *       this.trigger(\"hi\");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on(\"beforeHi\", (e) => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   * });\n   * some.on(\"hi\", (e) => {\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   */\n  public trigger<K extends EventKey<T>>(eventName: EventNoParamKey<T, K>): boolean;\n  public trigger<K extends EventKey<T>>(eventName: K, customEvent: FirstParam<T, K>, ...restParam: RestParam<T, K>): boolean;\n  public trigger<K extends EventKey<T>>(eventName: K, customEvent?: FirstParam<T, K>, ...restParam: any[]): boolean {\n    let handlerList = this._eventHandler[eventName] || [];\n    const hasHandlerList = handlerList.length > 0;\n\n    if (!hasHandlerList) {\n      return true;\n    }\n    if (!customEvent) {\n      customEvent = {} as any;\n    }\n\n    // If detach method call in handler in first time then handler list calls.\n    handlerList = handlerList.concat();\n\n    let isCanceled = false;\n\n    // This should be done like this to pass previous tests\n    (customEvent as any).eventType = eventName;\n    (customEvent as any).stop = () => { isCanceled = true; };\n    (customEvent as any).currentTarget = this;\n\n    let arg: any[] = [customEvent];\n\n    if (restParam.length >= 1) {\n      arg = arg.concat(restParam);\n    }\n\n    handlerList.forEach(handler => {\n      handler.apply(this, arg);\n    });\n\n    return !isCanceled;\n  }\n\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * class Some extends eg.Component {\n   * hi() {\n   *   alert(\"hi\");\n   * }\n   * thing() {\n   *   this.once(\"hi\", this.hi);\n   * }\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(\"hi\");\n   * // fire alert(\"hi\");\n   * some.trigger(\"hi\");\n   * // Nothing happens\n   */\n  public once<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public once(eventHash: EventHash<T, this>): this;\n  public once<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const key in eventHash) {\n        this.once((key as K), eventHash[key] as EventCallback<T, K, this>);\n      }\n      return this;\n    } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n      const listener: any = (...args: any[]) => {\n        handlerToAttach.apply(this, args);\n        this.off(eventName, listener);\n      }\n\n      this.on(eventName, listener);\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {String} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {Boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * class Some extends eg.Component {\n   *   some() {\n   *     this.hasOn(\"hi\");// check hi event.\n   *   }\n   * }\n   */\n  public hasOn<K extends EventKey<T>>(eventName: K): boolean {\n    return !!this._eventHandler[eventName];\n  }\n\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.on(\"hi\",this.hi); //attach event\n   *   }\n   * }\n   */\n  public on<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public on(eventHash: EventHash<T, this>): this;\n  public on<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const name in eventHash) {\n        this.on(name, eventHash[name] as any);\n      }\n\n      return this;\n    } else if (typeof eventName === \"string\" &&\n      typeof handlerToAttach === \"function\") {\n      let handlerList = this._eventHandler[eventName];\n\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n\n      handlerList.push(handlerToAttach as EventCallback<T, EventKey<T>, this>);\n    }\n\n    return this;\n  }\n\n  /**\n   * Detaches an event from the component.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다\n   * @param {eventName} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {Function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return {eg.Component} An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.off(\"hi\",this.hi); //detach event\n   *   }\n   * }\n   */\n  public off(eventHash?: EventHash<T, this>): this;\n  public off<K extends EventKey<T>>(eventName: K, handlerToDetach?: EventCallback<T, K, this>): this;\n  public off<K extends EventKey<T>>(eventName?: K | EventHash<T, this>, handlerToDetach?: EventCallback<T, K, this>): this {\n    // Detach all event handlers.\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    }\n\n    // Detach all handlers for eventname or detach event handlers by object.\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === \"string\") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        const eventHash = eventName;\n\n        for (const name in eventHash) {\n          this.off(name, eventHash[name] as any);\n        }\n        return this;\n      }\n    }\n\n    // Detach single event handler\n    const handlerList = this._eventHandler[eventName as K];\n\n    if (handlerList) {\n      let idx = 0;\n      for (const handlerFunction of handlerList) {\n        if (handlerFunction === handlerToDetach) {\n          handlerList.splice(idx, 1);\n          break;\n        }\n        idx++;\n      }\n    }\n\n    return this;\n  }\n}\n\nexport default Component;\n"],"names":["isUndefined","value","_eventHandler","eventName","customEvent","_i","restParam","handlerList","this","length","concat","isCanceled","eventType","stop","currentTarget","arg","forEach","handler","apply","_this","handlerToAttach","listener_1","key","eventHash","once","args","off","on","name","push","handlerToDetach","idx","handlerList_1","__values","splice","Component"],"mappings":";;;;;;;;wMAKA,SAASA,EAAYC,eACO,IAAVA,8CA6EuB,QAOhCC,cAAgB,sCAiCvB,SAAsCC,EAAcC,2BAAgCC,mBAAAA,IAAAC,wBAC9EC,EAAcC,KAAKN,cAAcC,IAAc,QACP,EAArBI,EAAYE,eAG1B,EAGPL,EADGA,GACW,GAIhBG,EAAcA,EAAYG,aAEtBC,GAAa,EAGhBP,EAAoBQ,UAAYT,EAChCC,EAAoBS,KAAO,WAAQF,GAAa,GAChDP,EAAoBU,cAAgBN,SAEjCO,EAAa,CAACX,UAEM,GAApBE,EAAUG,SACZM,EAAMA,EAAIL,OAAOJ,IAGnBC,EAAYS,QAAQ,SAAAC,GAClBA,EAAQC,MAAMC,EAAMJ,MAGdJ,UA4BV,SAAmCR,EAAmCiB,OAS5DC,YARiB,iBAAdlB,GAA0BH,EAAYoB,GAAkB,KAGtDE,EAFLC,EAAYpB,MAEPmB,KAAOC,OACXC,KAAMF,EAAWC,EAAUD,WAE3Bd,WACuB,iBAAdL,GAAqD,mBAApBiB,IAC3CC,EAAgB,4BAAChB,mBAAAA,IAAAoB,kBACrBL,EAAgBF,MAAMC,EAAMM,GAC5BN,EAAKO,IAAIvB,EAAWkB,SAGjBM,GAAGxB,EAAWkB,IAGdb,cAeT,SAAoCL,WACzBK,KAAKN,cAAcC,SAqB9B,SAAiCA,EAAmCiB,MACzC,iBAAdjB,GAA0BH,EAAYoB,GAAkB,KAGtDQ,EAFLL,EAAYpB,MAEPyB,KAAQL,OACZI,GAAGC,EAAML,EAAUK,WAGnBpB,KACF,IAEDD,QAF0B,iBAAdJ,GACW,mBAApBiB,IAGHpB,EAFAO,EAAcC,KAAKN,cAAcC,WAG9BD,cAAcC,GAAa,GAChCI,EAAcC,KAAKN,cAAcC,IAGnCI,EAAYsB,KAAKT,IAGZZ,YAqBT,SAAkCL,EAAoC2B,cAEhE9B,EAAYG,eACTD,cAAgB,GACdM,QAILR,EAAY8B,GAAkB,IACP,iBAAd3B,gBACFK,KAAKN,cAAcC,GACnBK,SAIIoB,EAFLL,EAAYpB,MAEPyB,KAAQL,OACZG,IAAIE,EAAML,EAAUK,WAEpBpB,SAKLD,EAAcC,KAAKN,cAAcC,MAEnCI,EAAa,KACXwB,EAAM,UACoB,IAAAC,2SAAAC,CAAA1B,iCAAa,cACjBuB,EAAiB,CACvCvB,EAAY2B,OAAOH,EAAK,SAG1BA,8GAIGvB,MA5OK2B,UAAkB"}