{"version":3,"file":"component.js","sources":["../src/Component.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nfunction isUndefined(value: any): boolean {\n  return typeof value === \"undefined\";\n}\n\ninterface DefaultProps<T> {\n  eventType: string;\n  stop: () => void;\n  currentTarget: T;\n}\ntype NotFunction = { [k: string]: unknown } & ({ bind?: never } | { call?: never });\ntype NoArguments = undefined | null | void | never;\ntype EventWithRestParam = ((evt: NotFunction, ...restParam: any[]) => any);\n\n/**\n * Types that can be used when attaching new event definition as generic on a class\n * @ko 클래스 타입 등록시 사용가능한 타입\n * @example\n * ```\n * new SomeClass<{\n *   // Using it as object\n *   evt0: {\n *     param0: number;\n *     param1: string\n *   };\n *   // Using it as function with other arguments\n *   evt1: (arg0: {\n *     param0: number;\n *     param1: string\n *   }, arg1: string, arg2: boolean) => boolean;\n * }>\n * ```\n */\ntype EventDefinition = NotFunction | NoArguments | EventWithRestParam;\n\ntype EventMap = Record<string, EventDefinition>;\ntype EventKey<T extends EventMap> = string & keyof T;\ntype EventHash<T extends EventMap, S> = Partial<{ [K in EventKey<T>]: EventCallback<T, K, S> }>;\n\n\ntype EventCallbackFirstParam<P, S> = P extends NoArguments ? DefaultProps<S> : P & DefaultProps<S>;\ntype EventCallbackFunction<T extends (...params: any[]) => any, S>\n  = T extends (firstParam?: infer F, ...restParams: infer R) => any\n  ? (firstParam: EventCallbackFirstParam<Required<F>, S>, ...restParams: R) => any\n  : (firstParam: DefaultProps<S>) => any;\n\n\n// In the on and once methods, the defaultProps must be included in the first parameter.\ntype EventCallback<T extends EventMap, K extends EventKey<T>, S>\n  = T[K] extends (...params: any[]) => any\n  ? EventCallbackFunction<T[K], S>\n  : (event: EventCallbackFirstParam<T[K], S>) => any;\n\ntype EventTriggerFirstParam<T extends {}> = Pick<T, Exclude<keyof T, keyof DefaultProps<any>>> & Partial<DefaultProps<any>>;\n\n\ntype EventDiff<T, U> = T extends U ? never : T;\ntype EventTriggerPartialFunction<T extends (...params: any[]) => any>\n  = T extends (firstParam: infer F, ...restParam: infer R) => any\n  ? (firstParam?: EventTriggerFirstParam<EventDiff<F, undefined>>, ...restParams: R) => any\n  : never;\n\ntype EventTriggerRequiredFunction<T extends (...params: any[]) => any>\n  = T extends (firstParam: infer F, ...restParam: infer R) => any\n  ? (firstParam: EventTriggerFirstParam<F>, ...restParams: R) => any\n  : never;\ntype EventTriggerFunction<T extends (...params: any[]) => any>\n  = Parameters<T> extends Required<Parameters<T>> & [any]\n  ? EventTriggerRequiredFunction<T>\n  : EventTriggerPartialFunction<T>\n\ntype EventTriggerNoFunction<T>\n  = T extends NoArguments\n  ? (firstParam?: { [key: string]: never }) => any\n  : EventTriggerFunction<(fisrtParam: EventTriggerFirstParam<T>) => any>;\n\n// You don't need to include defaultProps in the trigger method's first parameter.\ntype EventTriggerParams<T extends EventMap, K extends EventKey<T>>\n  = Parameters<T[K] extends (...params: any[]) => any\n    ? EventTriggerFunction<T[K]>\n    : EventTriggerNoFunction<T[K]>>;\n\ninterface DefaultEventMap {\n  [key: string]: (firstParam?: { [key: string]: any }, ...restParams: any[]) => any;\n}\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\nclass Component<T extends EventMap = DefaultEventMap> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * eg.Component.VERSION;  // ex) 2.0.0\n   * @memberof eg.Component\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n\n  /**\n   * @deprecated\n   * @private\n   */\n  public options: { [key: string]: any } = {};\n  private _eventHandler: { [keys: string]: EventCallback<T, EventKey<T>, Component<T>>[] };\n\n  /**\n   * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n   */\n  constructor() {\n    this._eventHandler = {};\n  }\n\n  public trigger<K extends EventKey<T>>(eventName: K, ...params: EventTriggerParams<T, K>): boolean;\n  /**\n   * Triggers a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n   * @param {object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @param {any[]} restParam Additional parameters when triggering a custom event <ko>커스텀 이벤트가 발생할 때 필요시 추가적으로 전달할 데이터</ko>\n   * @return Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">Ref</a> <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 'false'를 반환하고 이벤트 발생을 중단한다. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">참고</a></ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   some(){\n   *     if(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n   *       this.trigger(\"hi\");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on(\"beforeHi\", (e) => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   * });\n   * some.on(\"hi\", (e) => {\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */\n  public trigger<K extends EventKey<T>>(eventName: K, ...params: any[]): boolean {\n    let handlerList = this._eventHandler[eventName] || [];\n    const hasHandlerList = handlerList.length > 0;\n\n    if (!hasHandlerList) {\n      return true;\n    }\n    const customEvent = params[0] || {};\n    const restParams = params.slice(1);\n\n    // If detach method call in handler in first time then handler list calls.\n    handlerList = handlerList.concat();\n\n    let isCanceled = false;\n\n    // This should be done like this to pass previous tests\n    (customEvent as any).eventType = eventName;\n    (customEvent as any).stop = () => { isCanceled = true; };\n    (customEvent as any).currentTarget = this;\n\n    let arg: any[] = [customEvent];\n\n    if (restParams.length >= 1) {\n      arg = arg.concat(restParams);\n    }\n\n    handlerList.forEach(handler => {\n      handler.apply(this, arg);\n    });\n\n    return !isCanceled;\n  }\n\n  public once<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public once(eventHash: EventHash<T, this>): this;\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   * hi() {\n   *   alert(\"hi\");\n   * }\n   * thing() {\n   *   this.once(\"hi\", this.hi);\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(\"hi\");\n   * // fire alert(\"hi\");\n   * some.trigger(\"hi\");\n   * // Nothing happens\n   * ```\n   */\n  public once<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const key in eventHash) {\n        this.once((key as K), eventHash[key] as EventCallback<T, K, this>);\n      }\n      return this;\n    } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n      const listener: any = (...args: any[]) => {\n        handlerToAttach.apply(this, args);\n        this.off(eventName, listener);\n      }\n\n      this.on(eventName, listener);\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   some() {\n   *     this.hasOn(\"hi\");// check hi event.\n   *   }\n   * }\n   * ```\n   */\n  public hasOn<K extends EventKey<T>>(eventName: K): boolean {\n    return !!this._eventHandler[eventName];\n  }\n\n  public on<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public on(eventHash: EventHash<T, this>): this;\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.on(\"hi\",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */\n  public on<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const name in eventHash) {\n        this.on(name, eventHash[name] as any);\n      }\n\n      return this;\n    } else if (typeof eventName === \"string\" &&\n      typeof handlerToAttach === \"function\") {\n      let handlerList = this._eventHandler[eventName];\n\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n\n      handlerList.push(handlerToAttach as EventCallback<T, EventKey<T>, this>);\n    }\n\n    return this;\n  }\n\n  public off(eventHash?: EventHash<T, this>): this;\n  public off<K extends EventKey<T>>(eventName: K, handlerToDetach?: EventCallback<T, K, this>): this;\n  /**\n   * Detaches an event from the component.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다\n   * @param {string} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```\n   * class Some extends eg.Component {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.off(\"hi\",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */\n  public off<K extends EventKey<T>>(eventName?: K | EventHash<T, this>, handlerToDetach?: EventCallback<T, K, this>): this {\n    // Detach all event handlers.\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    }\n\n    // Detach all handlers for eventname or detach event handlers by object.\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === \"string\") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        const eventHash = eventName;\n\n        for (const name in eventHash) {\n          this.off(name, eventHash[name] as any);\n        }\n        return this;\n      }\n    }\n\n    // Detach single event handler\n    const handlerList = this._eventHandler[eventName as K];\n\n    if (handlerList) {\n      let idx = 0;\n      for (const handlerFunction of handlerList) {\n        if (handlerFunction === handlerToDetach) {\n          handlerList.splice(idx, 1);\n          break;\n        }\n        idx++;\n      }\n    }\n\n    return this;\n  }\n}\n\nexport default Component;\n"],"names":["isUndefined","value","_eventHandler","eventName","_i","params","handlerList","hasHandlerList","length","customEvent","restParams","slice","concat","isCanceled","eventType","stop","currentTarget","arg","forEach","handler","apply","_this","handlerToAttach","eventHash","key","once","listener_1","args","off","on","name","push","handlerToDetach","idx","handlerList_1","__values","handlerFunction","splice","Component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA;;;;;IAKA,SAASA,WAAT,CAAqBC,KAArB;IACE,SAAO,OAAOA,KAAP,KAAiB,WAAxB;IACD;IAmFD;;;;;;;IAKA;;;IAmBE;;;IAGA,oBAAA;IAVA;;;;IAIO,gBAAA,GAAkC,EAAlC;IAOL,SAAKC,aAAL,GAAqB,EAArB;IACD;IAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+BO,iBAAA,GAAP,UAAsCC,SAAtC;IAAA,oBAAA;;IAAoD,mBAAA;;aAAA,YAAAC,uBAAAA;IAAAC,MAAAA,cAAA,gBAAA;;;IAClD,QAAIC,WAAW,GAAG,KAAKJ,aAAL,CAAmBC,SAAnB,KAAiC,EAAnD;IACA,QAAMI,cAAc,GAAGD,WAAW,CAACE,MAAZ,GAAqB,CAA5C;;IAEA,QAAI,CAACD,cAAL,EAAqB;IACnB,aAAO,IAAP;IACD;;IACD,QAAME,WAAW,GAAGJ,MAAM,CAAC,CAAD,CAAN,IAAa,EAAjC;IACA,QAAMK,UAAU,GAAGL,MAAM,CAACM,KAAP,CAAa,CAAb,CAAnB;;IAGAL,IAAAA,WAAW,GAAGA,WAAW,CAACM,MAAZ,EAAd;IAEA,QAAIC,UAAU,GAAG,KAAjB;;IAGCJ,IAAAA,WAAmB,CAACK,SAApB,GAAgCX,SAAhC;;IACAM,IAAAA,WAAmB,CAACM,IAApB,GAA2B;IAAQF,MAAAA,UAAU,GAAG,IAAb;IAAoB,KAAvD;;IACAJ,IAAAA,WAAmB,CAACO,aAApB,GAAoC,IAApC;IAED,QAAIC,GAAG,GAAU,CAACR,WAAD,CAAjB;;IAEA,QAAIC,UAAU,CAACF,MAAX,IAAqB,CAAzB,EAA4B;IAC1BS,MAAAA,GAAG,GAAGA,GAAG,CAACL,MAAJ,CAAWF,UAAX,CAAN;IACD;;IAEDJ,IAAAA,WAAW,CAACY,OAAZ,CAAoB,UAAAC,OAAA;IAClBA,MAAAA,OAAO,CAACC,KAAR,CAAcC,KAAd,EAAoBJ,GAApB;IACD,KAFD;IAIA,WAAO,CAACJ,UAAR;IACD,GA/BM;IAmCP;;;;;;;;;;;;;;;;;;;;;;;;;;IAwBO,cAAA,GAAP,UAAmCV,SAAnC,EAAsEmB,eAAtE;IAAA,oBAAA;;IACE,QAAI,OAAOnB,SAAP,KAAqB,QAArB,IAAiCH,WAAW,CAACsB,eAAD,CAAhD,EAAmE;IACjE,UAAMC,SAAS,GAAGpB,SAAlB;;IAEA,WAAK,IAAMqB,GAAX,IAAkBD,SAAlB,EAA6B;IAC3B,aAAKE,IAAL,CAAWD,GAAX,EAAsBD,SAAS,CAACC,GAAD,CAA/B;IACD;;IACD,aAAO,IAAP;IACD,KAPD,MAOO,IAAI,OAAOrB,SAAP,KAAqB,QAArB,IAAiC,OAAOmB,eAAP,KAA2B,UAAhE,EAA4E;IACjF,UAAMI,UAAQ,GAAQ;IAAC,qBAAA;;iBAAA,YAAAtB,uBAAAA;IAAAuB,UAAAA,QAAA,gBAAA;;;IACrBL,QAAAA,eAAe,CAACF,KAAhB,CAAsBC,KAAtB,EAA4BM,IAA5B;;IACAN,QAAAA,KAAI,CAACO,GAAL,CAASzB,SAAT,EAAoBuB,UAApB;IACD,OAHD;;IAKA,WAAKG,EAAL,CAAQ1B,SAAR,EAAmBuB,UAAnB;IACD;;IAED,WAAO,IAAP;IACD,GAlBM;IAoBP;;;;;;;;;;;;;;;;IAcO,eAAA,GAAP,UAAoCvB,SAApC;IACE,WAAO,CAAC,CAAC,KAAKD,aAAL,CAAmBC,SAAnB,CAAT;IACD,GAFM;IAMP;;;;;;;;;;;;;;;;;;;;IAkBO,YAAA,GAAP,UAAiCA,SAAjC,EAAoEmB,eAApE;IACE,QAAI,OAAOnB,SAAP,KAAqB,QAArB,IAAiCH,WAAW,CAACsB,eAAD,CAAhD,EAAmE;IACjE,UAAMC,SAAS,GAAGpB,SAAlB;;IAEA,WAAK,IAAM2B,IAAX,IAAmBP,SAAnB,EAA8B;IAC5B,aAAKM,EAAL,CAAQC,IAAR,EAAcP,SAAS,CAACO,IAAD,CAAvB;IACD;;IAED,aAAO,IAAP;IACD,KARD,MAQO,IAAI,OAAO3B,SAAP,KAAqB,QAArB,IACT,OAAOmB,eAAP,KAA2B,UADtB,EACkC;IACvC,UAAIhB,WAAW,GAAG,KAAKJ,aAAL,CAAmBC,SAAnB,CAAlB;;IAEA,UAAIH,WAAW,CAACM,WAAD,CAAf,EAA8B;IAC5B,aAAKJ,aAAL,CAAmBC,SAAnB,IAAgC,EAAhC;IACAG,QAAAA,WAAW,GAAG,KAAKJ,aAAL,CAAmBC,SAAnB,CAAd;IACD;;IAEDG,MAAAA,WAAW,CAACyB,IAAZ,CAAiBT,eAAjB;IACD;;IAED,WAAO,IAAP;IACD,GAtBM;IA0BP;;;;;;;;;;;;;;;;;;;;IAkBO,aAAA,GAAP,UAAkCnB,SAAlC,EAAsE6B,eAAtE;;;;IAEE,QAAIhC,WAAW,CAACG,SAAD,CAAf,EAA4B;IAC1B,WAAKD,aAAL,GAAqB,EAArB;IACA,aAAO,IAAP;IACD;;;IAGD,QAAIF,WAAW,CAACgC,eAAD,CAAf,EAAkC;IAChC,UAAI,OAAO7B,SAAP,KAAqB,QAAzB,EAAmC;IACjC,eAAO,KAAKD,aAAL,CAAmBC,SAAnB,CAAP;IACA,eAAO,IAAP;IACD,OAHD,MAGO;IACL,YAAMoB,SAAS,GAAGpB,SAAlB;;IAEA,aAAK,IAAM2B,IAAX,IAAmBP,SAAnB,EAA8B;IAC5B,eAAKK,GAAL,CAASE,IAAT,EAAeP,SAAS,CAACO,IAAD,CAAxB;IACD;;IACD,eAAO,IAAP;IACD;IACF;;;IAGD,QAAMxB,WAAW,GAAG,KAAKJ,aAAL,CAAmBC,SAAnB,CAApB;;IAEA,QAAIG,WAAJ,EAAiB;IACf,UAAI2B,GAAG,GAAG,CAAV;;;IACA,aAA8B,IAAAC,gBAAAC,SAAA7B,YAAA,wCAA9B,uBAAA,wCAAA,EAA2C;IAAtC,cAAM8B,eAAe,wBAArB;;IACH,cAAIA,eAAe,KAAKJ,eAAxB,EAAyC;IACvC1B,YAAAA,WAAW,CAAC+B,MAAZ,CAAmBJ,GAAnB,EAAwB,CAAxB;IACA;IACD;;IACDA,UAAAA,GAAG;IACJ;;;;;;;;;;;;IACF;;IAED,WAAO,IAAP;IACD,GArCM;IA1NP;;;;;;;;;;;IAScK,EAAAA,iBAAA,GAAkB,OAAlB;IAuPhB,kBAAA;IAjQA,GAAA;;;;;;;;"}