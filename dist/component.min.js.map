{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///component.min.js","webpack:///webpack/bootstrap 24bd2b7f973c106c4a2e?db41","webpack:///./src/Component.js?6030","webpack:///./src/index.js?9552"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","obj","constructor","Component","_eventHandler","options","option","arguments","length","key","trigger","eventName","customEvent","undefined","handlerList","concat","eventType","isCanceled","arg","stop","_len","restParam","Array","_key2","apply","once","handlerToAttach","eventHash","self","on","listener","_len2","_key3","off","hasOn","push","handlerToDetach","k","handlerFunction","splice","_Component","_Component2","default","VERSION"],"mappings":"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","file":"component.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Component\"] = factory();\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Component\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Component\"] = factory();\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Component\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * A class used to manage events and options in a component\n * @ko 컴포넌트의 이벤트와 옵션을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\nvar Component = function () {\n\t/**\n  * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n  */\n\tfunction Component() {\n\t\t_classCallCheck(this, Component);\n\n\t\tthis._eventHandler = {};\n\t\tthis.options = {};\n\t}\n\n\t/**\n  * Sets options in a component or returns them.\n  * @ko 컴포넌트에 옵션을 설정하거나 옵션을 반환한다\n  * @param {String} key The key of the option<ko>옵션의 키</ko>\n  * @param {Object} [value] The option value that corresponds to a given key <ko>키에 해당하는 옵션값</ko>\n  * @return {eg.Component|Object} An instance, an option value, or an option object of a component itself.<br>- If both key and value are used to set an option, it returns an instance of a component itself.<br>- If only a key is specified for the parameter, it returns the option value corresponding to a given key.<br>- If nothing is specified, it returns an option object. <ko>컴포넌트 자신의 인스턴스나 옵션값, 옵션 객체.<br>- 키와 값으로 옵션을 설정하면 컴포넌트 자신의 인스턴스를 반환한다.<br>- 파라미터에 키만 설정하면 키에 해당하는 옵션값을 반환한다.<br>- 파라미터에 아무것도 설정하지 않으면 옵션 객체를 반환한다.</ko>\n  * @example\n class Some extends eg.Component {\n }\n const some = new Some({\n  \"foo\": 1,\n  \"bar\": 2\n });\n some.option(\"foo\"); // return 1\n some.option(\"foo\",3); // return some instance\n some.option(); // return options object.\n some.option({\n  \"foo\" : 10,\n  \"bar\" : 20,\n  \"baz\" : 30\n }); // return some instance.\n  */\n\n\n\tComponent.prototype.option = function option() {\n\t\tif (arguments.length >= 2) {\n\t\t\tvar _key = arguments.length <= 0 ? undefined : arguments[0];\n\t\t\tvar value = arguments.length <= 1 ? undefined : arguments[1];\n\n\t\t\tthis.options[_key] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tvar key = arguments.length <= 0 ? undefined : arguments[0];\n\n\t\tif (typeof key === \"string\") {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.options;\n\t\t}\n\n\t\tvar options = key;\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\t};\n\t/**\n  * Triggers a custom event.\n  * @ko 커스텀 이벤트를 발생시킨다\n  * @param {String} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n  * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n  * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 'false'를 반환하고 이벤트 발생을 중단한다.</ko>\n  * @example\n class Some extends eg.Component {\n  some(){\n    this.trigger(\"hi\");// fire hi event.\n  }\n }\n  */\n\n\n\tComponent.prototype.trigger = function trigger(eventName) {\n\t\tvar customEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tvar handlerList = this._eventHandler[eventName] || [];\n\t\tvar hasHandlerList = handlerList.length > 0;\n\n\t\tif (!hasHandlerList) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If detach method call in handler in first time then handeler list calls.\n\t\thandlerList = handlerList.concat();\n\n\t\tcustomEvent.eventType = eventName;\n\n\t\tvar isCanceled = false;\n\t\tvar arg = [customEvent];\n\t\tvar i = void 0;\n\n\t\tcustomEvent.stop = function () {\n\t\t\tisCanceled = true;\n\t\t};\n\n\t\tfor (var _len = arguments.length, restParam = Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {\n\t\t\trestParam[_key2 - 2] = arguments[_key2];\n\t\t}\n\n\t\tif (restParam.length >= 1) {\n\t\t\targ = arg.concat(restParam);\n\t\t}\n\n\t\tfor (i in handlerList) {\n\t\t\thandlerList[i].apply(this, arg);\n\t\t}\n\n\t\treturn !isCanceled;\n\t};\n\t/**\n  * Executed event just one time.\n  * @ko 이벤트가 한번만 실행된다.\n  * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    alert(\"hi\");\n  }\n  thing() {\n    this.once(\"hi\", this.hi);\n  }\n }\n var some = new Some();\n some.thing();\n some.trigger(\"hi\");\n // fire alert(\"hi\");\n some.trigger(\"hi\");\n // Nothing happens\n  */\n\n\n\tComponent.prototype.once = function once(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar i = void 0;\n\n\t\t\tfor (i in eventHash) {\n\t\t\t\tthis.once(i, eventHash[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar self = this;\n\n\t\t\tthis.on(eventName, function listener() {\n\t\t\t\tfor (var _len2 = arguments.length, arg = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n\t\t\t\t\targ[_key3] = arguments[_key3];\n\t\t\t\t}\n\n\t\t\t\thandlerToAttach.apply(self, arg);\n\t\t\t\tself.off(eventName, listener);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Checks whether an event has been attached to a component.\n  * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n  * @param {String} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n  * @return {Boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n  * @example\n class Some extends eg.Component {\n  some() {\n    this.hasOn(\"hi\");// check hi event.\n  }\n }\n  */\n\n\n\tComponent.prototype.hasOn = function hasOn(eventName) {\n\t\treturn !!this._eventHandler[eventName];\n\t};\n\n\t/**\n  * Attaches an event to a component.\n  * @ko 컴포넌트에 이벤트를 등록한다.\n  * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.on(\"hi\",this.hi); //attach event\n  }\n }\n */\n\n\n\tComponent.prototype.on = function on(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar name = void 0;\n\n\t\t\tfor (name in eventHash) {\n\t\t\t\tthis.on(name, eventHash[name]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\t\tif (typeof handlerList === \"undefined\") {\n\t\t\t\tthis._eventHandler[eventName] = [];\n\t\t\t\thandlerList = this._eventHandler[eventName];\n\t\t\t}\n\n\t\t\thandlerList.push(handlerToAttach);\n\t\t}\n\n\t\treturn this;\n\t};\n\t/**\n  * Detaches an event from the component.\n  * @ko 컴포넌트에 등록된 이벤트를 해제한다\n  * @param {eventName} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n  * @param {Function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.off(\"hi\",this.hi); //detach event\n  }\n }\n  */\n\n\n\tComponent.prototype.off = function off(eventName, handlerToDetach) {\n\t\t// All event detach.\n\t\tif (typeof eventName === \"undefined\") {\n\t\t\tthis._eventHandler = {};\n\t\t\treturn this;\n\t\t}\n\n\t\t// All handler of specific event detach.\n\t\tif (typeof handlerToDetach === \"undefined\") {\n\t\t\tif (typeof eventName === \"string\") {\n\t\t\t\tthis._eventHandler[eventName] = undefined;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\tvar eventHash = eventName;\n\t\t\t\tvar name = void 0;\n\n\t\t\t\tfor (name in eventHash) {\n\t\t\t\t\tthis.off(name, eventHash[name]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// The handler of specific event detach.\n\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\tif (handlerList) {\n\t\t\tvar k = void 0;\n\t\t\tvar handlerFunction = void 0;\n\n\t\t\tfor (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {\n\t\t\t\tif (handlerFunction === handlerToDetach) {\n\t\t\t\t\thandlerList = handlerList.splice(k, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\treturn Component;\n}();\n\nexports[\"default\"] = Component;\nmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _Component = __webpack_require__(0);\n\nvar _Component2 = _interopRequireDefault(_Component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n_Component2[\"default\"].VERSION = \"2.0.0-rc\";\nmodule.exports = _Component2[\"default\"];\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// component.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 24bd2b7f973c106c4a2e","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * A class used to manage events and options in a component\n * @ko 컴포넌트의 이벤트와 옵션을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\nclass Component {\n\t/**\n\t * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n\t */\n\tconstructor() {\n\t\tthis._eventHandler = {};\n\t\tthis.options = {};\n\t}\n\n\t/**\n\t * Sets options in a component or returns them.\n\t * @ko 컴포넌트에 옵션을 설정하거나 옵션을 반환한다\n\t * @param {String} key The key of the option<ko>옵션의 키</ko>\n\t * @param {Object} [value] The option value that corresponds to a given key <ko>키에 해당하는 옵션값</ko>\n\t * @return {eg.Component|Object} An instance, an option value, or an option object of a component itself.<br>- If both key and value are used to set an option, it returns an instance of a component itself.<br>- If only a key is specified for the parameter, it returns the option value corresponding to a given key.<br>- If nothing is specified, it returns an option object. <ko>컴포넌트 자신의 인스턴스나 옵션값, 옵션 객체.<br>- 키와 값으로 옵션을 설정하면 컴포넌트 자신의 인스턴스를 반환한다.<br>- 파라미터에 키만 설정하면 키에 해당하는 옵션값을 반환한다.<br>- 파라미터에 아무것도 설정하지 않으면 옵션 객체를 반환한다.</ko>\n\t * @example\nclass Some extends eg.Component {\n}\n\nconst some = new Some({\n  \"foo\": 1,\n  \"bar\": 2\n});\n\nsome.option(\"foo\"); // return 1\nsome.option(\"foo\",3); // return some instance\nsome.option(); // return options object.\nsome.option({\n  \"foo\" : 10,\n  \"bar\" : 20,\n  \"baz\" : 30\n}); // return some instance.\n\t */\n\toption(...args) {\n\t\tif (args.length >= 2) {\n\t\t\tconst key = args[0];\n\t\t\tconst value = args[1];\n\n\t\t\tthis.options[key] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst key = args[0];\n\n\t\tif (typeof key === \"string\") {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (args.length === 0) {\n\t\t\treturn this.options;\n\t\t}\n\n\t\tconst options = key;\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\t}\n\t/**\n\t * Triggers a custom event.\n\t * @ko 커스텀 이벤트를 발생시킨다\n\t * @param {String} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n\t * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n\t * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 'false'를 반환하고 이벤트 발생을 중단한다.</ko>\n\t * @example\nclass Some extends eg.Component {\n  some(){\n    this.trigger(\"hi\");// fire hi event.\n  }\n}\n\t */\n\ttrigger(eventName, customEvent = {}, ...restParam) {\n\t\tlet handlerList = this._eventHandler[eventName] || [];\n\t\tconst hasHandlerList = handlerList.length > 0;\n\n\t\tif (!hasHandlerList) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If detach method call in handler in first time then handeler list calls.\n\t\thandlerList = handlerList.concat();\n\n\t\tcustomEvent.eventType = eventName;\n\n\t\tlet isCanceled = false;\n\t\tlet arg = [customEvent];\n\t\tlet i;\n\n\t\tcustomEvent.stop = () => { isCanceled = true; };\n\n\n\t\tif (restParam.length >= 1) {\n\t\t\targ = arg.concat(restParam);\n\t\t}\n\n\t\tfor (i in handlerList) {\n\t\t\thandlerList[i].apply(this, arg);\n\t\t}\n\n\t\treturn !isCanceled;\n\t}\n\t/**\n\t * Executed event just one time.\n\t * @ko 이벤트가 한번만 실행된다.\n\t * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n\t * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n\t * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n\t * @example\nclass Some extends eg.Component {\n  hi() {\n    alert(\"hi\");\n  }\n  thing() {\n    this.once(\"hi\", this.hi);\n  }\n}\n\nvar some = new Some();\nsome.thing();\nsome.trigger(\"hi\");\n// fire alert(\"hi\");\nsome.trigger(\"hi\");\n// Nothing happens\n\t */\n\tonce(eventName, handlerToAttach) {\n\t\tif (typeof eventName === \"object\" &&\n\t\t\ttypeof handlerToAttach === \"undefined\") {\n\t\t\tconst eventHash = eventName;\n\t\t\tlet i;\n\n\t\t\tfor (i in eventHash) {\n\t\t\t\tthis.once(i, eventHash[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" &&\n\t\t\ttypeof handlerToAttach === \"function\") {\n\t\t\tconst self = this;\n\n\t\t\tthis.on(eventName, function listener(...arg) {\n\t\t\t\thandlerToAttach.apply(self, arg);\n\t\t\t\tself.off(eventName, listener);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Checks whether an event has been attached to a component.\n\t * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n\t * @param {String} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n\t * @return {Boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n\t * @example\nclass Some extends eg.Component {\n  some() {\n    this.hasOn(\"hi\");// check hi event.\n  }\n}\n\t */\n\thasOn(eventName) {\n\t\treturn !!this._eventHandler[eventName];\n\t}\n\n\t/**\n\t * Attaches an event to a component.\n\t * @ko 컴포넌트에 이벤트를 등록한다.\n\t * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n\t * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n\t * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n\t * @example\nclass Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.on(\"hi\",this.hi); //attach event\n  }\n}\n*/\n\ton(eventName, handlerToAttach) {\n\t\tif (typeof eventName === \"object\" &&\n\t\t\ttypeof handlerToAttach === \"undefined\") {\n\t\t\tconst eventHash = eventName;\n\t\t\tlet name;\n\n\t\t\tfor (name in eventHash) {\n\t\t\t\tthis.on(name, eventHash[name]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" &&\n\t\t\ttypeof handlerToAttach === \"function\") {\n\t\t\tlet handlerList = this._eventHandler[eventName];\n\n\t\t\tif (typeof handlerList === \"undefined\") {\n\t\t\t\tthis._eventHandler[eventName] = [];\n\t\t\t\thandlerList = this._eventHandler[eventName];\n\t\t\t}\n\n\t\t\thandlerList.push(handlerToAttach);\n\t\t}\n\n\t\treturn this;\n\t}\n\t/**\n\t * Detaches an event from the component.\n\t * @ko 컴포넌트에 등록된 이벤트를 해제한다\n\t * @param {eventName} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n\t * @param {Function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n\t * @return {eg.Component} An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n\t * @example\nclass Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.off(\"hi\",this.hi); //detach event\n  }\n}\n\t */\n\toff(eventName, handlerToDetach) {\n\t\t// All event detach.\n\t\tif (typeof eventName === \"undefined\") {\n\t\t\tthis._eventHandler = {};\n\t\t\treturn this;\n\t\t}\n\n\t\t// All handler of specific event detach.\n\t\tif (typeof handlerToDetach === \"undefined\") {\n\t\t\tif (typeof eventName === \"string\") {\n\t\t\t\tthis._eventHandler[eventName] = undefined;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\tconst eventHash = eventName;\n\t\t\t\tlet name;\n\n\t\t\t\tfor (name in eventHash) {\n\t\t\t\t\tthis.off(name, eventHash[name]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// The handler of specific event detach.\n\t\tlet handlerList = this._eventHandler[eventName];\n\n\t\tif (handlerList) {\n\t\t\tlet k;\n\t\t\tlet handlerFunction;\n\n\t\t\tfor (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {\n\t\t\t\tif (handlerFunction === handlerToDetach) {\n\t\t\t\t\thandlerList = handlerList.splice(k, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\nexport default Component;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Component.js","import Component from \"./Component\";\n\nComponent.VERSION = \"2.0.0-rc\";\nmodule.exports = Component;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}